# 权限控制组件使用说明

## 概述

增强的 `Permission` 组件是一个基于 ABP 框架的权限控制组件，支持多种条件检查：权限、功能特性、全局功能特性和设置。该组件通过 `abpStore` 获取服务端配置数据，确保权限检查的准确性和安全性。

## 特性

- ✅ **权限检查**：支持单个或多个权限码的检查
- ✅ **功能特性检查**：支持功能特性的启用状态检查
- ✅ **全局功能特性检查**：支持全局功能特性的启用状态检查
- ✅ **设置检查**：支持各种类型设置值的检查和比较
- ✅ **多模式匹配**：每种检查类型都支持"满足一个"或"满足所有"的匹配模式
- ✅ **安全优先**：配置未加载或加载失败时默认不显示内容
- ✅ **加载状态**：支持显示加载中的替代内容
- ✅ **组合条件**：支持多种条件的组合检查

## 基本用法

### 组件方式

```tsx
import Permission from '@/components/Permission';

// 基本权限检查
<Permission permissions="User.Create">
  <button>创建用户</button>
</Permission>
```

### Hook 方式 (推荐用于复杂组件)

```tsx
import { usePermission } from '@/components/Permission';

// 基本用法
const hasCreatePermission = usePermission({ permissions: 'User.Create' });

// 在JSX中使用条件渲染
function MyComponent() {
  return (
    <div>
      {usePermission({ permissions: 'Admin.Dashboard' }) && <ComplexDashboard />}
      {usePermission({ permissions: 'User.Create' }) && <CreateUserButton />}
    </div>
  );
}
```

## 属性说明

### 权限相关属性

| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `permissions` | `string \| string[]` | - | 权限码，支持单个或多个 |
| `permissionMode` | `'every' \| 'some'` | `'every'` | 权限匹配模式：`every`（满足所有）或 `some`（满足一个） |

### 功能特性相关属性

| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `features` | `string \| string[]` | - | 功能特性名称，支持单个或多个 |
| `featureMode` | `'every' \| 'some'` | `'every'` | 功能匹配模式：`every`（满足所有）或 `some`（满足一个） |

### 全局功能特性相关属性

| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `globalFeatures` | `string \| string[]` | - | 全局功能特性名称，支持单个或多个 |
| `globalFeatureMode` | `'every' \| 'some'` | `'every'` | 全局功能匹配模式：`every`（满足所有）或 `some`（满足一个） |

### 设置相关属性

| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `settings` | `SettingCondition \| SettingCondition[]` | - | 设置条件，支持单个或多个 |
| `settingMode` | `'every' \| 'some'` | `'every'` | 设置匹配模式：`every`（满足所有）或 `some`（满足一个） |

### 其他属性

| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `children` | `React.ReactNode` | - | 需要权限控制的子组件 |
| `fallback` | `React.ReactNode` | `null` | 无权限时的替代内容 |
| `loading` | `React.ReactNode` | `null` | 配置加载中的替代内容 |
| `requireAll` | `boolean` | `true` | 是否需要满足所有条件（权限、功能、设置） |
| `noPermissionStrategy` | `'fallback' \| 'render' \| 'hide'` | `'fallback'` | 无权限时的渲染策略 |
| `disabledProps` | `Record<string, any>` | `{}` | 使用render策略时传递给子组件的禁用属性 |

### 设置条件接口 (SettingCondition)

```tsx
interface SettingCondition {
  name: string; // 设置名称
  value?: string; // 期望的字符串值
  boolValue?: boolean; // 期望的布尔值
  intValue?: number; // 期望的整数值
  operator?: 'equals' | 'notEquals' | 'greaterThan' | 'lessThan' | 'greaterOrEqual' | 'lessOrEqual'; // 比较操作符
}
```

### 无权限时的渲染策略

组件支持三种无权限时的渲染策略：

- **`fallback`**（默认）：显示 `fallback` 属性指定的替代内容，如果没有指定则为 `null`
- **`render`**：仍然渲染子组件，但会自动添加 `disabled: true` 属性以及 `disabledProps` 中指定的其他属性
- **`hide`**：完全不渲染任何内容（返回 `null`），适用于复杂组件的性能优化

## 使用示例

### 1. usePermission Hook 使用示例

#### 基本用法

```tsx
import { usePermission } from '@/components/Permission';

function UserManagement() {
  const canCreate = usePermission({ permissions: 'User.Create' });
  const canEdit = usePermission({ permissions: 'User.Edit' });
  const canDelete = usePermission({ permissions: 'User.Delete' });

  return (
    <div>
      {canCreate && <button>创建用户</button>}
      {canEdit && <button>编辑用户</button>}
      {canDelete && <button>删除用户</button>}
    </div>
  );
}
```

#### 避免复杂组件的不必要渲染

```tsx
function Dashboard() {
  return (
    <div>
      {/* ✅ 推荐：使用hook避免复杂组件的不必要渲染 */}
      {usePermission({ permissions: 'Admin.Analytics' }) && (
        <ExpensiveAnalyticsComponent />
      )}
      
      {/* ✅ 组合条件检查 */}
      {usePermission({ 
        permissions: ['Report.View', 'Report.Generate'],
        features: 'ReportModule.Enable',
        requireAll: true 
      }) && (
        <ComplexReportingDashboard />
      )}
      
      {/* ❌ 避免：即使组件内部不渲染，这里也已经创建了组件实例 */}
      <Permission permissions="Admin.Analytics">
        <ExpensiveAnalyticsComponent />
      </Permission>
    </div>
  );
}
```

#### 在自定义Hook中使用

```tsx
// 创建业务相关的权限Hook
function useUserManagementPermissions() {
  const canCreateUser = usePermission({ permissions: 'User.Create' });
  const canEditUser = usePermission({ permissions: 'User.Edit' });
  const canDeleteUser = usePermission({ permissions: 'User.Delete' });
  const canManageRoles = usePermission({ 
    permissions: ['Role.Create', 'Role.Edit', 'Role.Delete'],
    permissionMode: 'some'
  });

  return {
    canCreateUser,
    canEditUser, 
    canDeleteUser,
    canManageRoles,
    hasAnyUserPermission: canCreateUser || canEditUser || canDeleteUser
  };
}

// 在组件中使用
function UserManagementPanel() {
  const permissions = useUserManagementPermissions();
  
  if (!permissions.hasAnyUserPermission) {
    return <div>您没有用户管理权限</div>;
  }

  return (
    <div>
      {permissions.canCreateUser && <CreateUserForm />}
      {permissions.canManageRoles && <RoleManagementPanel />}
    </div>
  );
}
```

### 2. Permission 组件使用示例

#### 基本权限检查

```tsx
// 单个权限
<Permission permissions="User.Create">
  <button>创建用户</button>
</Permission>

// 多个权限（需要全部满足）
<Permission permissions={['User.Create', 'User.Edit']}>
  <button>管理用户</button>
</Permission>

// 多个权限（满足其中一个即可）
<Permission 
  permissions={['User.Create', 'User.Edit']} 
  permissionMode="some"
>
  <button>用户操作</button>
</Permission>
```

### 2. 功能特性检查

```tsx
// 检查功能特性是否启用
<Permission features="Chat.Enable">
  <div>聊天功能</div>
</Permission>

// 检查多个功能特性
<Permission 
  features={['Chat.Enable', 'Notification.Enable']}
  featureMode="some"
>
  <div>通讯功能</div>
</Permission>
```

### 3. 全局功能特性检查

```tsx
// 检查全局功能特性
<Permission globalFeatures="GlobalChat">
  <div>全局聊天</div>
</Permission>
```

### 4. 设置检查

```tsx
// 布尔设置检查
<Permission 
  settings={{
    name: 'AllowUserRegistration',
    boolValue: true
  }}
>
  <button>注册</button>
</Permission>

// 字符串设置检查
<Permission 
  settings={{
    name: 'AppMode',
    value: 'Production'
  }}
>
  <div>生产环境功能</div>
</Permission>

// 数值设置检查
<Permission 
  settings={{
    name: 'MaxFileSize',
    intValue: 10,
    operator: 'greaterOrEqual'
  }}
>
  <button>上传大文件</button>
</Permission>

// 多个设置条件
<Permission 
  settings={[
    { name: 'AllowUpload', boolValue: true },
    { name: 'MaxFileSize', intValue: 5, operator: 'greaterThan' }
  ]}
  settingMode="every"
>
  <button>文件上传</button>
</Permission>
```

### 5. 组合条件检查

```tsx
// 同时检查权限、功能和设置（需要全部满足）
<Permission 
  permissions="File.Upload"
  features="FileManagement.Enable"
  settings={{
    name: 'AllowFileUpload',
    boolValue: true
  }}
  requireAll={true}
>
  <button>上传文件</button>
</Permission>

// 检查多种条件，满足其中一种即可
<Permission 
  permissions="Admin.FullAccess"
  features="SuperUser.Enable"
  requireAll={false}
>
  <div>管理功能</div>
</Permission>
```

### 6. 自定义回退内容

```tsx
// 无权限时显示提示信息
<Permission 
  permissions="User.Create"
  fallback={<div style={{color: 'gray'}}>您没有创建用户的权限</div>}
>
  <button>创建用户</button>
</Permission>

// 加载中显示加载提示
<Permission 
  permissions="User.Create"
  loading={<div>权限检查中...</div>}
  fallback={<div>无权限访问</div>}
>
  <button>创建用户</button>
</Permission>
```

### 7. 无权限时的不同渲染策略

```tsx
// 策略1: fallback - 显示替代内容（默认行为）
<Permission 
  permissions="User.Create"
  noPermissionStrategy="fallback"
  fallback={<div style={{color: 'gray'}}>无权限创建用户</div>}
>
  <button>创建用户</button>
</Permission>

// 策略2: render - 渲染禁用状态的组件
<Permission 
  permissions="User.Edit"
  noPermissionStrategy="render"
  disabledProps={{
    style: { opacity: 0.5 },
    title: '您没有编辑权限'
  }}
>
  <button>编辑用户</button>
</Permission>

// 策略3: hide - 完全不渲染（适用于复杂组件）
<Permission 
  permissions="Admin.ViewDashboard"
  noPermissionStrategy="hide"
>
  <ComplexDashboardComponent />
</Permission>

// 自定义禁用状态的样式
<Permission 
  permissions="File.Delete"
  noPermissionStrategy="render"
  disabledProps={{
    disabled: true,
    className: 'no-permission',
    style: { 
      backgroundColor: '#f5f5f5',
      color: '#ccc',
      cursor: 'not-allowed'
    },
    onClick: (e) => {
      e.preventDefault();
      alert('您没有删除文件的权限');
    }
  }}
>
  <button>删除文件</button>
</Permission>
```

### 8. 复杂业务场景

```tsx
// VIP 用户专享功能
<Permission 
  settings={[
    { name: 'UserLevel', value: 'VIP' },
    { name: 'VipExpireDate', value: new Date().toISOString().split('T')[0], operator: 'greaterThan' }
  ]}
  permissions="VipFeature.Access"
>
  <div>VIP 专享内容</div>
</Permission>

// 根据租户配置显示功能
<Permission 
  globalFeatures="MultiTenancy"
  settings={{
    name: 'TenantFeatureEnabled',
    boolValue: true
  }}
>
  <div>多租户功能</div>
</Permission>
```

## 最佳实践

### 1. 选择合适的权限检查方式

```tsx
// ✅ 复杂组件：使用usePermission hook避免不必要的渲染
{usePermission({ permissions: 'Admin.Dashboard' }) && <ComplexDashboard />}

// ✅ 简单UI组件：使用Permission组件提供更好的用户反馈
<Permission 
  permissions="User.Create"
  fallback={<button disabled>创建用户（无权限）</button>}
>
  <button>创建用户</button>
</Permission>

// ✅ 需要禁用状态：使用Permission组件的render策略
<Permission 
  permissions="User.Edit"
  noPermissionStrategy="render"
>
  <EditButton />
</Permission>
```

### 2. 安全优先

```tsx
// ❌ 错误：没有权限检查
<button onClick={deleteUser}>删除用户</button>

// ✅ 正确：添加权限检查
<Permission permissions="User.Delete">
  <button onClick={deleteUser}>删除用户</button>
</Permission>
```

### 2. 提供用户友好的反馈

```tsx
// ✅ 推荐：提供明确的无权限提示
<Permission 
  permissions="User.Create"
  fallback={
    <Tooltip title="您没有创建用户的权限，请联系管理员">
      <button disabled>创建用户</button>
    </Tooltip>
  }
>
  <button>创建用户</button>
</Permission>
```

### 3. 合理使用匹配模式

```tsx
// 管理功能：需要所有权限
<Permission 
  permissions={['User.Create', 'User.Edit', 'User.Delete']}
  permissionMode="every"
>
  <div>用户管理</div>
</Permission>

// 查看功能：满足其中一个权限即可
<Permission 
  permissions={['User.View', 'User.Edit', 'User.Delete']}
  permissionMode="some"
>
  <div>用户信息</div>
</Permission>
```

### 4. 渲染策略选择

```tsx
// ✅ 简单组件：使用render策略，保持UI一致性
<Permission 
  permissions="User.Create"
  noPermissionStrategy="render"
>
  <button>创建用户</button>
</Permission>

// ✅ 复杂组件：使用hide策略，提升性能
<Permission 
  permissions="Admin.ViewAnalytics"
  noPermissionStrategy="hide"
>
  <ComplexAnalyticsChart />
</Permission>

// ✅ 重要提示：使用fallback策略，提供明确反馈
<Permission 
  permissions="System.Backup"
  noPermissionStrategy="fallback"
  fallback={<Alert type="warning">需要系统管理员权限</Alert>}
>
  <BackupButton />
</Permission>
```

### 5. 性能考虑

```tsx
// ✅ 推荐：将复杂的权限检查提取到组件外部
const canManageUsers = useMemo(() => ({
  permissions: ['User.Create', 'User.Edit'],
  features: 'UserManagement.Enable',
  settings: { name: 'AllowUserManagement', boolValue: true }
}), []);

<Permission {...canManageUsers}>
  <UserManagementPanel />
</Permission>

// ✅ 对于复杂组件，使用hide策略避免不必要的渲染
<Permission 
  permissions="Heavy.Computation"
  noPermissionStrategy="hide"
>
  <ExpensiveComponent />
</Permission>
```

## 常见问题

### Q: 何时使用 usePermission Hook，何时使用 Permission 组件？

A: 根据不同场景选择：

**使用 usePermission Hook 的情况：**
- 复杂组件或性能敏感的组件，避免不必要的渲染
- 需要在组件逻辑中使用权限状态进行条件判断
- 创建自定义的权限相关 Hook
- 简单的条件渲染场景

**使用 Permission 组件的情况：**
- 需要提供用户友好的无权限反馈（fallback内容）
- 需要禁用状态而不是隐藏组件（render策略）
- 简单的UI组件包装
- 需要loading状态显示

### Q: 组件如何处理配置加载失败的情况？

A: 出于安全考虑，当 ABP 配置加载失败时，组件会显示 `fallback` 内容而不是 `children`，确保敏感功能不会因为配置问题而意外暴露。

### Q: 可以同时检查多种类型的条件吗？

A: 可以。组件支持同时检查权限、功能特性、全局功能特性和设置。通过 `requireAll` 属性可以控制是需要满足所有类型的条件还是满足其中一种即可。

### Q: 设置检查支持哪些比较操作？

A: 支持以下操作：
- `equals`（默认）：等于
- `notEquals`：不等于
- `greaterThan`：大于
- `lessThan`：小于
- `greaterOrEqual`：大于等于
- `lessOrEqual`：小于等于

### Q: 何时使用不同的渲染策略？

A: 根据不同场景选择合适的策略：
- **`fallback`**：需要明确告知用户无权限的情况，提供用户友好的反馈
- **`render`**：保持UI布局一致性，只是禁用交互功能，适用于按钮、表单等简单组件
- **`hide`**：完全隐藏功能，适用于复杂组件或敏感功能，同时提升性能

### Q: 使用render策略时，如何处理复杂的子组件？

A: `render` 策略最适合单个 React 元素。对于复杂结构：

```tsx
// ❌ 不推荐：多个子元素
<Permission noPermissionStrategy="render">
  <div>标题</div>
  <button>操作</button>
</Permission>

// ✅ 推荐：包装在单个元素中
<Permission noPermissionStrategy="render">
  <div>
    <div>标题</div>
    <button>操作</button>
  </div>
</Permission>
```

### Q: 如何调试权限检查？

A: 可以在浏览器控制台查看 ABP 配置和权限信息：

```javascript
// 查看当前用户权限
console.log(useAbpStore.getState().config?.auth.grantedPolicies);

// 查看功能特性
console.log(useAbpStore.getState().config?.features.values);

// 查看设置
console.log(useAbpStore.getState().config?.setting.values);
```

## 注意事项

1. **确保 ABP 配置已加载**：组件依赖于 `abpStore` 中的配置数据，确保在使用前已调用 `loadConfiguration()`
2. **安全性**：组件采用"安全优先"的设计，未知情况下默认不显示受保护的内容
3. **性能**：
   - 避免在渲染频繁的组件中使用复杂的权限检查条件
   - 对于复杂组件，优先使用 `hide` 策略避免不必要的渲染开销
   - 合理使用 `render` 策略，仅用于简单的UI组件
4. **渲染策略选择**：
   - `render` 策略要求 children 是单个有效的 React 元素
   - 复杂的组件结构建议使用 `fallback` 或 `hide` 策略
   - 注意 `disabledProps` 可能会覆盖子组件的原有属性
5. **一致性**：建议在项目中统一权限命名规范和渲染策略使用规范，便于管理和维护